# Flutter: лучшие практики

## Архитектура клиента
- Используем **MVVM + Provider/riverpod** для управления состоянием экранов.
- Навигация через `go_router`; маршруты описываем декларативно, учитывая deeplink из пушей.
- Разделяем слой данных (`repositories`), домена (`use_cases`), UI (`views/widgets`).

## Работа с сетью
- HTTP-клиент оборачиваем в `ApiClient` с перехватчиками для токенов и логов.
- Повтор запросов с backoff для сетевых ошибок, но не более 3 попыток.
- Сериализация через `json_serializable`, время передаём в ISO8601 + timezone.

## UI и доступность
- Используем дизайн-токены из `UI_Kit/Design_Tokens.json` и кастомные `ThemeExtension`.
- Минимальный размер тапа 44×44, контраст текста WCAG AA.
- Все иконки и тексты должны поддерживать тёмную тему; тестируем на эмуляторах iOS/Android.

## Офлайн
- Локальное хранилище `sqflite` + `hive` для быстрых настроек.
- Очередь синхронизации хранит pending-операции; при восстановлении сети выполняем батчами.
- Конфликты показываем пользователю (баннер) с выбором варианта или автопринятием сервера.

## Качество
- Unit-тесты для `use_cases` и мапперов, widget-тесты для ключевых экранов (календарь, задачи, финансы).
- Включаем `flutter analyze`, `dart format`, `dart test` в pre-push hook.
- Производительность проверяем `profile`-сборкой: время фрейма < 16 мс на целевых девайсах Pixel 6 / iPhone 12.
