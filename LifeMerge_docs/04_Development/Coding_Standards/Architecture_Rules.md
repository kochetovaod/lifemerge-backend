# Архитектурные правила LifeMerge

Документ обобщает договорённости из TECHNICAL SPECIFICATIONS и ТЗ для реализации Flutter-клиента, backend и AI-сервисов.

## Базовые принципы
- **Слойность:** презентация → application/service → domain → infrastructure. Прямых зависимостей от UI к хранилищу нет.
- **Чистые модели:** DTO для сети/БД, domain-модели для логики, мапперы обязательны.
- **Idempotency & retries:** все mutating-эндпоинты backend принимают `request_id` для безопасных повторов.
- **Трассировка:** каждый запрос несёт `X-Request-Id`; логируем путь, пользователя, время, статус.

## Интеграции
- **AI-сервис:** отдельный REST, вызывается backend-воркерами. UI не ходит к AI напрямую.
- **Платёжки/FCM/APNs:** обёрнуты адаптерами; конфиги через переменные окружения.

## Данные и офлайн
- **Единый источник истины:** серверная БД PostgreSQL. Клиент хранит кеш (sqflite) + очередь синхронизации.
- **Версионирование схемы:** миграции через `migration_version`; несовместимые изменения только по фичефлагу.
- **Конфликты:** правило «последний апдейт выигрывает» с сохранением истории изменений для задач/событий.

## Безопасность
- JWT access (15–30 мин) + refresh; все сервисы ходят только по HTTPS.
- Роли: user, admin, support; проверка авторизации на уровне handler + сервис.
- PII и финансовые суммы логируются только в хэшированном/маскированном виде.

## Производительность
- Пагинация по cursor/`updated_at`, лимит 50 записей по умолчанию.
- Индексы по `(user_id, due_date)`, `(user_id, status)` для задач, `(user_id, date)` для транзакций.
- Критичные запросы тестируются на 95‑перцентиль не более 200 мс в stage-среде.
